# Dice!插件自定义牌堆格式

关于Dice!插件自定义牌堆格式，笔者目前还没找到什么文档，所以只能自己试着整理一下。

目前该文档中整理的内容已在笔者的机器人骰子插件（Dice_python）里面做实现。

---

## 概述

一个自定义牌堆通常由包含一个json字符串的单个.json或.txt格式文件构成。

* 文件编码是UTF-8。目前笔者的插件（Dice_python）和Dice!插件的大多数版本都能处理UTF-8-sig，不过在Dice!的某些远古版本或特殊版本中里似乎不太行，[在Dice!官方论坛看到的“不太行”情况](https://forum.kokona.tech/d/103-yuan-chuang-pai-dui-jin-ri-te-yin)。所以还是推荐UTF-8。

整体格式如下：

    {
        "牌堆1":["卡片1","卡片2",……],
        "牌堆2":["卡片1","卡片2",……],
        ……
    }

如你所见，就是个json字符串，很简单。

在这个示例中，当你对机器人使用 `.draw 牌堆1` 时，机器人就会在牌堆里面随机挑一张卡给你了。

> 你：.draw 牌堆1
>  
> 机器人：看看【你的昵称】抽到了什么？卡片1

---

## 卡片内代码

只是输出单纯文字的话那也太单调了。下面介绍一些卡片内的代码。

### 换行

    "我换行了\n这是新的一行"

* 加个 `\n` 就行。我都不确定这是否值得单独列个小标题出来（

### 调用牌堆

    "这张卡片调用了{牌堆名}"

* 调用牌堆时，会从目标牌堆中选择一张卡片，替换掉文本中的 `“{牌堆名}”` 。

调用可以嵌套，以实现复杂的效果。例如PublicDeck.json中，就有：

    ……
    "正逆": ["正位", "逆位"],
    "塔罗牌占卜": ["随机牌阵：{塔罗牌阵}"],
    "塔罗牌阵":
        [
        "单张塔罗牌\n{单张塔罗牌}", "圣三角牌阵\n{圣三角牌阵}", "四要素牌阵\n{四要素牌阵}", "小十字牌阵\n{小十字牌阵}", "六芒星牌阵\n{六芒星牌阵}",
            "凯尔特十字牌阵\n{凯尔特十字牌阵}"
        ]
    ,
    "单张塔罗牌":
        [
    ……

当你 `.draw 塔罗牌占卜` 时，就会在 `塔罗牌阵` 中先选择一个卡片。

假定选中的是 `"单张塔罗牌\n{单张塔罗牌}"` ，那就会继续从 `单张塔罗牌` 牌堆里面选择一张，替换掉 `{单张塔罗牌}` 文字。以此类推。

* **注意！Dice! 插件特殊的调用情况**
  
    在Dice! 插件中存在 `“不放回抽取”` 和 `“放回抽取”` 两种抽卡模式，都是字面意思，很好理解，实在不能理解去逮一个Dice! 机器人 `.help draw` ，在此不赘述。在Dice! 插件中，直接使用 `{}` 的牌堆调用为 `“不放回抽取”` ，在牌堆名前面加一个 `%` 的牌堆调用（形如 `{%单张塔罗牌}` ）为 `“放回抽取”`。

    但是，在Dice_python插件中，由于写不放回抽取要消耗笔者额外的脑细胞，而且用处不如放回抽取大。故笔者的插件里面不管加不加 `%` ，最终的结果都是不放回抽卡。加了没事，不加也行。

### 调用骰子

    "这张卡片调用了[骰子式]"

调用骰子时，会执行骰子式得到结果，那这个数替换掉文本中的“[骰子式]”。

示例：

    ……
    "1d100":["1d100=[1d100]"],
    ……

当你 `.draw 1d100` 时，机器人就会回答例如

> 1d100=99

这样的话。

### 多张重复卡片简化表示

    "::n::这张卡片变成了n张"

* 抽取卡片时，每张卡牌的概率均等。有些时候，你希望卡片的概率不均等（例如简单的抽卡模拟器），可以采用复制卡片好几遍的方式（卡片允许重复）。但是，手动复制卡片从效率和可读性上都不行，运用 `::n::` 简化重复卡片表示就非常实用。

示例：以下两种卡片表达形式等价

    "::5::五张卡"
    "5张卡","5张卡","5张卡","5张卡","5张卡"

### CQ码

* 直接写在卡片里。

CQ码是让机器人发出多媒体信息的手段。通过CQ码，机器人可以发送表情、@、图片、语音等复杂信息，甚至可以进行戳一戳、音乐自定义分享等功能。

[Dice!](https://github.com/Dice-Developer-Team/Dice) 插件最初诞生并应用于 CKYU 平台（酷Q平台），在 CKYU 停止运营后借助 [Mirai Native](https://github.com/iTXTech/mirai-native) 移植到了 [Mirai](https://github.com/mamoe/mirai/tree/master) 平台。
Dice_python 插件基于 [Nonebot](https://docs.nonebot.dev/) ，而 Nonebot 基于各个机器人平台的 [Onebot](https://github.com/botuniverse/onebot) 实现与机器人平台进行沟通（Onebot 协议是对 [CQHTTP](https://github.com/kyubotics/coolq-http-api) 内部协议的外延，而 CQHTTP 是酷Q平台著名的插件，利用http协议和ws协议，实现外部软件与机器人的交互）。
所以，这两个插件在理论上来说，对CQ码都是天然兼容的。

**不同机器人平台对CQ码的使用可能存在一些小的不同**。此处贴几个笔者常用的CQ码文档，按需前往。

Onebot：<https://github.com/botuniverse/onebot/blob/master/v11/specs/message/segment.md>（Onebot 协议下的CQ码，最全）

Mirai Native：<https://github.com/iTXTech/mirai-native/wiki/Docs#cq%E7%A0%81>（适用于 Mirai 平台下运行的bot）

go-cqhttp：<https://docs.go-cqhttp.org/cqcode/>（适用于 [go-cqhttp](https://docs.go-cqhttp.org/) 平台下运行的bot）

表情 CQ 码 ID 表：<https://github.com/kyubotics/coolq-http-api/wiki/%E8%A1%A8%E6%83%85-CQ-%E7%A0%81-ID-%E8%A1%A8>
